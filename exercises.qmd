---
title: "Exercises"
editor:
  render-on-save: true
---

<details open="true">
<summary>Exercises 1: discover reactive programming with the logistic model</summary>

Goal: convert the code located at `./assets/1_shiny/logistic/verhulst.R` into a Shiny app. By the end
of this exercise, you should be able to know how to build a basic Shiny app, that is, 
what is part of the ui and the server.

```{r, warning=FALSE, message=FALSE}
library(ggplot2)
library(dplyr)

# Read and transform data
ver <- read.table(
  "http://pbil.univ-lyon1.fr/R/donnees/VerhulstPF1847.txt",
  sep = "\t",
  header = TRUE
) |>
  mutate(obs = obs / 10^6, theo = theo / 10^6)

t0 <- ver$t[1]
N0 <- ver$obs[1]

# Model equations
logistic <- function(t, p) {
  with(as.list(p), {
    K / (1 + ((K - N0) / N0) * exp(-r * (t - t0)))
  })
}

# Minimize
sce <- function(p) {
  theo <- logistic(ver$t, p = setNames(p, c("r", "K")))
  # Least squears
  sum((ver$obs - theo)^2)
}

# Fit: K = 5 means 5 millions people max (*10^6)
nlmfit <- nlm(f = sce, p = c(0.02, 5))

# Calculate model with predicted coefficients
tseq <- seq(from = 1800, to = 2000, by = 1)
res <- data.frame(
  t = tseq,
  y = logistic(tseq, p = setNames(nlmfit$estimate, c("r", "K")))
)

# Add linear model alternative
lm_coef <- coef(lm(ver$obs ~ ver$t))

# Plot everything
ggplot(data = res) +
  geom_line(mapping = aes(x = t, y = y), color = "red") +
  geom_point(
    data = ver,
    mapping = aes(x = t, y = obs)
  ) +
  geom_abline(
    slope = lm_coef[2],
    intercept = lm_coef[1],
    color = "grey",
    linetype = "dashed"
  ) +
  labs(
    x = "Year",
    y = "Population in million",
    title = "Population growth in Belgium"
  )
```

1. Create an `app.R` file with this template:

```r
library(shiny)

ui <- fluidPage(
  
)

server <- function(input, output, session) {
  
}

shinyApp(ui, server)
```

2. Within the `ui` object, create 2 input widgets for `r` and `K` parameters. You can use `?shiny::numericInput` for guidance.
3. Importantly, anything that isn't reactive can live outside the server function like the `logistic` function definition and other objects:

```r
logistic <- function(t, p) {
  with(as.list(p), {
    K / (1 + ((K - N0)/N0) * exp(-r*(t-t0)))
  })
}
...
```

3. In the `server` object, create a reactive that calculate the predicted values by the logistic equation given the 2 UI input parameters (this isn't the adjusted model):

```r
res <- reactive({
  # Calculate model with input parameter
  data.frame(
    t = tseq,
    y = logistic(tseq, p = c(r = <INPUT_1>, K = <INPUT_2>)))
  )
})
```

4. In the `server` object use the `res` reactive expression to plot the data:

```r
# Replace TBD by what is relevant
output$<TBD> <- render<TBD>({
  ggplot(data = <TBD>) +
  geom_line(mapping = aes(x = t, y = y), color = "red") +
  geom_point(
    data = ver,
    mapping = aes(x = t, y = obs)
  ) +
  geom_abline(
    slope = lm_coef[2],
    intercept = lm_coef[1],
    color = "grey",
    linetype = "dashed"
  ) +
  labs(
    x = "Year",
    y = "Population in million",
    title = "Population growth in belgium"
  )
})
```

Don't forget to add the corresponding `*Output` container in the ui part.

5. Run the app and try to change `r` and `K`.

6. Let's fit the model. Create another `reactive` expression that returns the best
fit and corresponding predicted results:

```r
fit <- reactive({
  # Replace <INPUT_1>, <INPUT_2> by what is defined in ui
  nlmfit <- nlm(f = sce, p = c(<INPUT_1>, <INPUT_2>))

  # Calculate model with predicted coefficients
  data.frame(
    t = tseq,
    y = logistic(tseq, p = setNames(nlmfit$estimate, c("r", "K")))
  )
})
```

7. Modify the existing `output` to include the new fitted curve. Replace `<TBD>` by the relevant value:

```r
output$plot <- renderPlot({
    ggplot(data = res()) +
      geom_line(mapping = aes(x = t, y = y)) +
      # Model fit curve
      geom_line(data = <TBD>, mapping = aes(x = t, y = y), color = "red") +
      geom_point(
        data = ver,
        mapping = aes(x = t, y = obs)
      ) +
      geom_abline(
        slope = lm_coef[2],
        intercept = lm_coef[1],
        color = "grey",
        linetype = "dashed"
      ) +
      labs(
        x = "Year",
        y = "Population in million",
        title = "Population growth in belgium"
      )
  })
```

</details>


<details open="false">
<summary>Exercises 2: kmeans clustering on the palmerpenguins dataset</summary>

Goal: improve the application at `./assets/1_shiny/kmeans/tiny-app.R`. You don't need to change the server
part of the application, as this exercise focuses on UI customisation.

1. Use the `page_sidebar()` to split __input__ and __output__. Typically you can start from something like:

```r
page_sidebar(
  title = "K-means Clustering of Palmer Penguins",
  sidebar = sidebar(
    title = "Controls",
    # INPUT CONTROLS
  ),
  # MAIN CONTENT (PLOTS)
)
```

2. Replace the `radioButtons()` by a more relevant widget. You can do the same for `numericInput()` and `checkboxInput()`.
3. Move the plot to the main content area.

</details>
